package gexport

import (
	"encoding/json"
	"fmt"
)

type jsonRes = map[string]interface{}

type Json struct {
	results  map[string]jsonRes
	isInline bool
}

func NewJson(isInline ...bool) *Json {
	var def bool
	if len(isInline) == 1 {
		def = isInline[0]
	}
	return &Json{isInline: def, results: make(map[string]jsonRes)}
}

func (j *Json) Parse(raw string) ([]string, error) {

	res, err := j.parseJson([]byte(raw))
	if err != nil {
		return []string{}, err
	}
	if j.isInline {
		j.results[DefaultStructName] = res
	} else {
		j.dimensionalReduction(res, DefaultStructName)
	}

	var structResults []string

	for key, result := range j.results {

		structure := j.generated(result)
		fullStruct := TName(NameCamelCase(key)) + structure
		structResults = append(structResults, fullStruct)
	}

	return structResults, nil
}

func (j *Json) parseJson(input []byte) (jsonRes, error) {
	var result jsonRes
	err := json.Unmarshal(input, &result)
	return result, err
}

func (j *Json) dimensionalReduction(raw jsonRes, key string) {
	j.results[key] = raw
	for fieldName, value := range raw {
		switch value.(type) {

		case []interface{}:
			val, ok := value.([]interface{})
			if !ok {
				continue
			}

			first := val[0]

			subRaw := first.(map[string]interface{})

			j.dimensionalReduction(subRaw, fieldName)
		case interface{}:
			subRaw, ok := value.(jsonRes)
			if !ok {
				continue
			}
			j.dimensionalReduction(subRaw, fieldName)
		default:
			continue
		}
	}
}

//generated create isInline struct AutoGenerated
func (j *Json) generated(raw jsonRes) string {
	gs := NewGoStruct("")
	gs.Start()
	for fieldName, value := range raw {
		var fieldType string
		switch value.(type) {
		case string:
			fieldType = "string"
		case int, int8, int16, int32, int64, uint, uint8, uint16, uint32, uint64:
			fieldType = "int64"
		case float32, float64:
			fieldType = "float64"

		case bool:
			fieldType = "bool"
		case []string:
			fieldType = "[]string"
		case []int:
			fieldType = "[]int"
		case []bool:
			fieldType = "[]bool"

		case []interface{}:
			val := value.([]interface{})
			if len(val) == 0 {
				fieldType = "[]interface{}"
			} else {
				if j.isInline {
					first := val[0]
					subRaw := first.(map[string]interface{})
					fieldType = fmt.Sprintf("[]%s", j.generated(subRaw))
				} else {
					fieldType = fmt.Sprintf("[]%s", NameCamelCase(fieldName))

				}
			}

		default:
			if j.isInline {
				subRaw := value.(jsonRes)
				fieldType = j.generated(subRaw)
			} else {
				fieldType = NameCamelCase(fieldName)
			}

		}
		//添加json标签
		jsonTag := CreateJsonTag(fieldName)
		gs.Field(fieldName, fieldType, jsonTag)
	}
	gs.End()

	return gs.StringNotType()
}
